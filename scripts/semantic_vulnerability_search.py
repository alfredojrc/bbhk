#!/usr/bin/env python3
"""
Semantic Vulnerability Search Interface
=====================================

Advanced search interface for vulnerability research using vector embeddings.
Provides natural language querying across all vulnerability research collections.

Author: AI Vector Embeddings Specialist
Date: 2025-08-26
Purpose: Semantic search and discovery for vulnerability research
"""

import requests
import json
import logging
from typing import List, Dict, Any, Optional, Tuple
from sentence_transformers import SentenceTransformer
import argparse
from datetime import datetime
import sys

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class SemanticVulnerabilitySearch:
    """
    Advanced semantic search interface for vulnerability research data.
    """
    
    def __init__(self, qdrant_url: str = 'http://localhost:6333'):
        self.qdrant_url = qdrant_url
        self.model = SentenceTransformer('all-MiniLM-L6-v2')
        
        # Available collections with descriptions
        self.collections = {
            "vulnerability_research": "Core vulnerability patterns and attack vectors",
            "attack_patterns": "Attack methodologies and exploitation techniques",
            "evidence_packages": "PoC descriptions and evidence summaries",
            "research_methodology": "T.K.V.F., D.I.E. framework and research processes",
            "target_platforms": "Technology-specific vulnerability patterns"
        }
    
    def search(self, 
               query: str, 
               collection: str = "all",
               limit: int = 5,
               score_threshold: float = 0.7,
               filters: Optional[Dict[str, Any]] = None) -> Dict[str, List[Dict[str, Any]]]:
        """
        Perform semantic search across collections.
        
        Args:
            query: Natural language search query
            collection: Specific collection or "all" for cross-collection search
            limit: Maximum number of results per collection
            score_threshold: Minimum similarity score threshold
            filters: Optional filters for payload fields
            
        Returns:
            Dictionary with collection names as keys and results as values
        """
        logger.info(f"üîç Searching for: '{query}'")
        
        # Generate query embedding
        query_embedding = self.model.encode([query])[0].tolist()
        
        # Determine collections to search
        collections_to_search = [collection] if collection != "all" else list(self.collections.keys())
        
        results = {}
        
        for coll_name in collections_to_search:
            if coll_name not in self.collections:
                logger.warning(f"Unknown collection: {coll_name}")
                continue
                
            try:
                # Build search request
                search_request = {
                    "vector": query_embedding,
                    "limit": limit,
                    "score_threshold": score_threshold,
                    "with_payload": True,
                    "with_vector": False
                }
                
                # Add filters if provided
                if filters:
                    search_request["filter"] = filters
                
                # Perform search
                response = requests.post(
                    f"{self.qdrant_url}/collections/{coll_name}/points/search",
                    json=search_request
                )
                
                if response.status_code == 200:
                    search_results = response.json()
                    results[coll_name] = search_results.get("result", [])
                    logger.info(f"‚úÖ Found {len(results[coll_name])} results in {coll_name}")
                else:
                    logger.error(f"‚ùå Search failed for {coll_name}: {response.text}")
                    results[coll_name] = []
                    
            except Exception as e:
                logger.error(f"Error searching {coll_name}: {e}")
                results[coll_name] = []
        
        return results
    
    def search_similar_vulnerabilities(self, 
                                     vulnerability_type: str,
                                     severity: str = None,
                                     limit: int = 10) -> List[Dict[str, Any]]:
        """
        Find vulnerabilities similar to a specific type and severity.
        """
        query = f"{vulnerability_type} vulnerability"
        if severity:
            query += f" {severity} severity"
        
        filters = {}
        if severity:
            filters["must"] = [{"key": "severity", "match": {"value": severity.upper()}}]
        
        results = self.search(
            query=query,
            collection="vulnerability_research",
            limit=limit,
            filters=filters
        )
        
        return results.get("vulnerability_research", [])
    
    def find_attack_patterns_by_difficulty(self, 
                                         min_difficulty: int = 1,
                                         max_difficulty: int = 10,
                                         platform: str = None) -> List[Dict[str, Any]]:
        """
        Find attack patterns within a specific difficulty range.
        """
        query = f"attack pattern difficulty {min_difficulty} to {max_difficulty}"
        if platform:
            query += f" on {platform}"
        
        filters = {
            "must": [
                {
                    "key": "difficulty",
                    "range": {
                        "gte": min_difficulty,
                        "lte": max_difficulty
                    }
                }
            ]
        }
        
        if platform:
            filters["must"].append({
                "key": "platform",
                "match": {"value": platform}
            })
        
        results = self.search(
            query=query,
            collection="attack_patterns",
            limit=20,
            filters=filters
        )
        
        return results.get("attack_patterns", [])
    
    def search_by_payout_range(self, 
                              min_payout: int,
                              max_payout: int = None) -> List[Dict[str, Any]]:
        """
        Find vulnerabilities within a specific payout range.
        """
        query = f"vulnerability payout range ${min_payout}"
        if max_payout:
            query += f" to ${max_payout}"
        
        filters = {
            "must": [
                {
                    "key": "payout_min",
                    "range": {"gte": min_payout}
                }
            ]
        }
        
        if max_payout:
            filters["must"].append({
                "key": "payout_max",
                "range": {"lte": max_payout}
            })
        
        results = self.search(
            query=query,
            collection="vulnerability_research",
            limit=15,
            filters=filters
        )
        
        return results.get("vulnerability_research", [])
    
    def get_research_methodology(self, framework: str) -> List[Dict[str, Any]]:
        """
        Get specific research methodology information.
        """
        query = f"{framework} framework methodology"
        
        results = self.search(
            query=query,
            collection="research_methodology",
            limit=5
        )
        
        return results.get("research_methodology", [])
    
    def analyze_technology_risks(self, technology: str) -> Dict[str, Any]:
        """
        Comprehensive risk analysis for a specific technology.
        """
        # Search across multiple collections for comprehensive analysis
        vulnerability_results = self.search(
            query=f"{technology} vulnerability patterns",
            collection="vulnerability_research",
            limit=10
        )
        
        attack_results = self.search(
            query=f"{technology} attack methods",
            collection="attack_patterns", 
            limit=10
        )
        
        platform_results = self.search(
            query=f"{technology} platform analysis",
            collection="target_platforms",
            limit=5
        )
        
        # Compile comprehensive analysis
        analysis = {
            "technology": technology,
            "search_timestamp": datetime.now().isoformat(),
            "vulnerability_patterns": vulnerability_results.get("vulnerability_research", []),
            "attack_methods": attack_results.get("attack_patterns", []),
            "platform_info": platform_results.get("target_platforms", []),
            "risk_summary": self._generate_risk_summary(
                vulnerability_results.get("vulnerability_research", []),
                attack_results.get("attack_patterns", []),
                platform_results.get("target_platforms", [])
            )
        }
        
        return analysis
    
    def _generate_risk_summary(self, 
                              vulnerabilities: List[Dict],
                              attacks: List[Dict], 
                              platforms: List[Dict]) -> Dict[str, Any]:
        """
        Generate risk summary from search results.
        """
        summary = {
            "total_patterns_found": len(vulnerabilities) + len(attacks),
            "severity_distribution": {},
            "difficulty_distribution": {},
            "payout_ranges": [],
            "key_risks": []
        }
        
        # Analyze severity distribution
        for vuln in vulnerabilities:
            severity = vuln.get("payload", {}).get("severity", "Unknown")
            summary["severity_distribution"][severity] = summary["severity_distribution"].get(severity, 0) + 1
        
        # Analyze difficulty distribution
        for attack in attacks:
            difficulty = attack.get("payload", {}).get("difficulty", 0)
            if difficulty > 0:
                summary["difficulty_distribution"][str(difficulty)] = summary["difficulty_distribution"].get(str(difficulty), 0) + 1
        
        # Extract payout ranges
        for vuln in vulnerabilities:
            payout_range = vuln.get("payload", {}).get("payout_range", "")
            if payout_range and payout_range not in summary["payout_ranges"]:
                summary["payout_ranges"].append(payout_range)
        
        # Extract key risks
        for result in vulnerabilities + attacks:
            description = result.get("payload", {}).get("description", "")
            if len(description) > 50:  # Meaningful description
                summary["key_risks"].append(description[:200] + "..." if len(description) > 200 else description)
        
        return summary
    
    def interactive_search(self) -> None:
        """
        Interactive search interface.
        """
        print("\nüéØ SEMANTIC VULNERABILITY SEARCH")
        print("=" * 50)
        print("Available collections:")
        for name, desc in self.collections.items():
            print(f"  ‚Ä¢ {name}: {desc}")
        print("\nCommands:")
        print("  ‚Ä¢ search <query> [collection] - Semantic search")
        print("  ‚Ä¢ vuln <type> [severity] - Find similar vulnerabilities")
        print("  ‚Ä¢ attack <min_diff> <max_diff> [platform] - Find attack patterns")
        print("  ‚Ä¢ payout <min> [max] - Search by payout range")
        print("  ‚Ä¢ method <framework> - Get methodology info")
        print("  ‚Ä¢ analyze <technology> - Comprehensive risk analysis")
        print("  ‚Ä¢ quit - Exit")
        print("=" * 50)
        
        while True:
            try:
                command = input("\nüîç Enter command: ").strip()
                
                if command.lower() in ['quit', 'exit', 'q']:
                    break
                
                parts = command.split()
                if not parts:
                    continue
                
                cmd = parts[0].lower()
                
                if cmd == "search":
                    if len(parts) < 2:
                        print("Usage: search <query> [collection]")
                        continue
                    
                    query = " ".join(parts[1:])
                    collection = "all"
                    
                    # Check if last part is a collection name
                    if parts[-1] in self.collections:
                        collection = parts[-1]
                        query = " ".join(parts[1:-1])
                    
                    results = self.search(query, collection)
                    self._display_results(results, query)
                
                elif cmd == "vuln":
                    if len(parts) < 2:
                        print("Usage: vuln <type> [severity]")
                        continue
                    
                    vuln_type = parts[1]
                    severity = parts[2] if len(parts) > 2 else None
                    
                    results = self.search_similar_vulnerabilities(vuln_type, severity)
                    self._display_vulnerability_results(results, vuln_type)
                
                elif cmd == "attack":
                    if len(parts) < 3:
                        print("Usage: attack <min_difficulty> <max_difficulty> [platform]")
                        continue
                    
                    try:
                        min_diff = int(parts[1])
                        max_diff = int(parts[2])
                        platform = parts[3] if len(parts) > 3 else None
                        
                        results = self.find_attack_patterns_by_difficulty(min_diff, max_diff, platform)
                        self._display_attack_results(results, min_diff, max_diff)
                    except ValueError:
                        print("Difficulty levels must be integers")
                
                elif cmd == "payout":
                    if len(parts) < 2:
                        print("Usage: payout <min> [max]")
                        continue
                    
                    try:
                        min_payout = int(parts[1])
                        max_payout = int(parts[2]) if len(parts) > 2 else None
                        
                        results = self.search_by_payout_range(min_payout, max_payout)
                        self._display_payout_results(results, min_payout, max_payout)
                    except ValueError:
                        print("Payout amounts must be integers")
                
                elif cmd == "method":
                    if len(parts) < 2:
                        print("Usage: method <framework>")
                        continue
                    
                    framework = parts[1]
                    results = self.get_research_methodology(framework)
                    self._display_methodology_results(results, framework)
                
                elif cmd == "analyze":
                    if len(parts) < 2:
                        print("Usage: analyze <technology>")
                        continue
                    
                    technology = parts[1]
                    analysis = self.analyze_technology_risks(technology)
                    self._display_analysis(analysis)
                
                else:
                    print(f"Unknown command: {cmd}")
                    
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"Error: {e}")
        
        print("\nüëã Goodbye!")
    
    def _display_results(self, results: Dict[str, List], query: str) -> None:
        """Display search results in a formatted way."""
        print(f"\nüìä Results for '{query}':")
        print("-" * 40)
        
        total_results = sum(len(results_list) for results_list in results.values())
        if total_results == 0:
            print("No results found.")
            return
        
        for collection_name, collection_results in results.items():
            if not collection_results:
                continue
                
            print(f"\nüéØ {collection_name} ({len(collection_results)} results):")
            
            for i, result in enumerate(collection_results[:3], 1):  # Show top 3
                payload = result.get("payload", {})
                score = result.get("score", 0)
                
                name = payload.get("name", payload.get("vulnerability_type", "Unknown"))
                description = payload.get("description", "")[:150] + "..."
                
                print(f"  {i}. {name} (Score: {score:.3f})")
                print(f"     {description}")
                
                # Show relevant metadata
                if "severity" in payload:
                    print(f"     Severity: {payload['severity']}")
                if "payout_range" in payload:
                    print(f"     Payout: ${payload['payout_range']}")
                if "difficulty" in payload:
                    print(f"     Difficulty: {payload['difficulty']}/10")
                
                print()
    
    def _display_vulnerability_results(self, results: List[Dict], vuln_type: str) -> None:
        """Display vulnerability search results."""
        print(f"\nüêõ Vulnerabilities similar to '{vuln_type}':")
        print("-" * 40)
        
        if not results:
            print("No vulnerabilities found.")
            return
        
        for i, result in enumerate(results, 1):
            payload = result.get("payload", {})
            score = result.get("score", 0)
            
            print(f"{i}. {payload.get('vulnerability_type', 'Unknown')} (Score: {score:.3f})")
            print(f"   Severity: {payload.get('severity', 'Unknown')}")
            print(f"   Pattern: {payload.get('pattern', 'N/A')}")
            print(f"   Payout: ${payload.get('payout_range', 'Unknown')}")
            print(f"   Program: {payload.get('program_handle', 'Unknown')}")
            print()
    
    def _display_attack_results(self, results: List[Dict], min_diff: int, max_diff: int) -> None:
        """Display attack pattern search results."""
        print(f"\n‚öîÔ∏è Attack patterns (difficulty {min_diff}-{max_diff}):")
        print("-" * 40)
        
        if not results:
            print("No attack patterns found.")
            return
        
        for i, result in enumerate(results, 1):
            payload = result.get("payload", {})
            score = result.get("score", 0)
            
            print(f"{i}. {payload.get('name', 'Unknown')} (Score: {score:.3f})")
            print(f"   Difficulty: {payload.get('difficulty', 'N/A')}/10")
            print(f"   Platform: {payload.get('platform', 'Unknown')}")
            print(f"   Impact: {payload.get('impact_level', 'Unknown')}")
            print(f"   Technique: {payload.get('technique', 'N/A')[:100]}...")
            print()
    
    def _display_payout_results(self, results: List[Dict], min_payout: int, max_payout: int = None) -> None:
        """Display payout-based search results."""
        range_text = f"${min_payout}+" if max_payout is None else f"${min_payout}-${max_payout}"
        print(f"\nüí∞ Vulnerabilities in payout range {range_text}:")
        print("-" * 40)
        
        if not results:
            print("No vulnerabilities found in this payout range.")
            return
        
        # Sort by payout max
        sorted_results = sorted(results, key=lambda x: x.get("payload", {}).get("payout_max", 0), reverse=True)
        
        for i, result in enumerate(sorted_results, 1):
            payload = result.get("payload", {})
            score = result.get("score", 0)
            
            print(f"{i}. {payload.get('vulnerability_type', 'Unknown')} (Score: {score:.3f})")
            print(f"   Payout: ${payload.get('payout_range', 'Unknown')}")
            print(f"   Severity: {payload.get('severity', 'Unknown')}")
            print(f"   Program: {payload.get('program_handle', 'Unknown')}")
            print()
    
    def _display_methodology_results(self, results: List[Dict], framework: str) -> None:
        """Display methodology search results."""
        print(f"\nüî¨ Methodology: {framework}")
        print("-" * 40)
        
        if not results:
            print("No methodology information found.")
            return
        
        for result in results:
            payload = result.get("payload", {})
            
            print(f"Framework: {payload.get('framework', 'Unknown')}")
            print(f"Name: {payload.get('name', 'Unknown')}")
            print(f"Description: {payload.get('description', 'N/A')}")
            print(f"Phase: {payload.get('phase', 'Unknown')}")
            print(f"Effectiveness: {payload.get('effectiveness', 0)*100:.1f}%")
            
            if payload.get('steps'):
                print("Steps:")
                for step in payload['steps'][:3]:  # Show first 3 steps
                    print(f"  ‚Ä¢ {step}")
            
            if payload.get('lessons_learned'):
                print(f"Key Lesson: {payload['lessons_learned']}")
            
            print()
    
    def _display_analysis(self, analysis: Dict[str, Any]) -> None:
        """Display comprehensive technology analysis."""
        print(f"\nüéØ Risk Analysis: {analysis['technology']}")
        print("=" * 50)
        
        summary = analysis['risk_summary']
        
        print(f"üìä Summary:")
        print(f"  ‚Ä¢ Total patterns found: {summary['total_patterns_found']}")
        print(f"  ‚Ä¢ Vulnerability patterns: {len(analysis['vulnerability_patterns'])}")
        print(f"  ‚Ä¢ Attack methods: {len(analysis['attack_methods'])}")
        print(f"  ‚Ä¢ Platform information: {len(analysis['platform_info'])}")
        
        if summary['severity_distribution']:
            print(f"\nüö® Severity Distribution:")
            for severity, count in summary['severity_distribution'].items():
                print(f"  ‚Ä¢ {severity}: {count}")
        
        if summary['payout_ranges']:
            print(f"\nüí∞ Payout Ranges Found:")
            for payout in summary['payout_ranges'][:5]:
                print(f"  ‚Ä¢ ${payout}")
        
        if summary['key_risks']:
            print(f"\n‚ö†Ô∏è Key Risk Areas:")
            for risk in summary['key_risks'][:3]:
                print(f"  ‚Ä¢ {risk}")
        
        print()

def main():
    """Main CLI interface."""
    parser = argparse.ArgumentParser(description="Semantic Vulnerability Search Interface")
    parser.add_argument("--interactive", "-i", action="store_true", help="Launch interactive mode")
    parser.add_argument("--query", "-q", type=str, help="Search query")
    parser.add_argument("--collection", "-c", type=str, default="all", help="Collection to search")
    parser.add_argument("--limit", "-l", type=int, default=5, help="Result limit")
    parser.add_argument("--analyze", "-a", type=str, help="Technology to analyze")
    
    args = parser.parse_args()
    
    # Initialize search interface
    search = SemanticVulnerabilitySearch()
    
    if args.interactive:
        search.interactive_search()
    elif args.query:
        results = search.search(args.query, args.collection, args.limit)
        search._display_results(results, args.query)
    elif args.analyze:
        analysis = search.analyze_technology_risks(args.analyze)
        search._display_analysis(analysis)
    else:
        print("Use --interactive, --query, or --analyze. See --help for details.")

if __name__ == "__main__":
    main()